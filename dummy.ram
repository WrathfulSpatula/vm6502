ORG
$0200
;
; test program #1
; address: $0200
; load Acc with value 12
; write Acc to address $c000 (49152)
;
; nop
; nop
; lda #$0c
; sta $c000
; brk
;
$EA $EA $A9 $0c $8D $00 $c0 $00 $00
;
; test program #2
; address: $0400
; copy 0-terminated string from
; address $d000 to $0200
; "Hello World!"
;
; ORG=$0400
; hello:
;    ldx #0
; loop:
;    lda $d000,x
;    beq $06  ;branch to end (+6) if A=0
;    sta $0200,x
;    inx
;    bne $f5  ; branch to loop (-11) if X<>0
; end:
;    brk
ORG
$0400
$A2 $00
$BD $00 $d0
$F0 $06
$9D $00 $02
$E8
$D0 $F5
$00 $00
; data
; address: $d000
ORG
$D000
;DEC: 53248
; "Hello World!"
72 101 108 108 111 32 87 111 114 108 100 33 0
;
; test program #3 - copy Hello World! string to $0300
;                   using different assembly instructions
; address: $0500
;
; ORG=$0500 ;dec: 1280
; hello:
;    lda #0
;    sta $05
;    ldx $05
; loop:
;    lda $d000,x
;    sta $0300,x
;    beq end ;(+6)
;    inx
;    beq end ;(+3)
;    jmp loop
; end:
;    brk
ORG
$0500
;DEC: 1280
$A9 $00
$85 $05
$A6 $05
$BD $00 $d0
$9D $00 $03
$F0 $06
$E8
$F0 $03
$4C $06 $05
$00 $00
;
; test program #4
; left-shift memory location $05 at zero page,
; then location $06 using zero page indexed addressing,
; then memory location $c001 (outside zero page) using absolute addressing
; then location $c002 using indexed absolute addressing
; and finally left-shift Acc.
; stop after each step for debugging
; exit loop when Acc=0
;
; start:
;    lda #$ff
;    ldx #$01
;    sta $05
;    sta $05,x
;    sta $c000,x
;    inx
;    sta $c000,x
;    ldx #$01
; loop2:
;    brk
;    asl $05
;    asl $05,x
;    asl $c001
;    asl $c001,x
;    asl
;    bne loop2 ;(-15 or $f1)
;    brk
ORG
$0600
$A9 $FF
$A2 $01
$85 $05
$95 $05
$9D $00 $C0
$E8
$9D $00 $C0
$A2 $01
$00 $00
$06 $05
$16 $05
$0E $01 $C0
$1E $01 $C0
$0A
$D0 $F1
$00 $00
;
; test program #5
; Test ORA opcode with various arguments and addressing modes.
; At each break, the contents of Acc should equal $AA.
;
; start:
;    lda #$aa     ;%10101010
;    sta $05
;    sta $aa
;    lda #$00
;    tax
;    ora ($05,x)
;    brk
;    lda #$00
;    ora $05
;    brk
;    lda #$00
;    ora #$aa
;    brk
;    lda #$00
;    ora $0005
;    brk
;    lda #$05
;    sta $06
;    lda #$00
;    sta $07
;    tay
;    ora ($06),y
;    brk
;    lda #$00
;    tax
;    ora $05,x
;    brk
;    lda #$00
;    tay
;    ora $0005,y
;    brk
;    lda #$00
;    tax
;    ora $0005,x
;    brk
ORG
$0700
$A9 $AA
$85 $05
$85 $AA
$A9 $00
$AA
$01 $05
$00 $00
$A9 $00
$05 $05
$00 $00
$A9 $00
$09 $AA
$00 $00
$A9 $00
$0D $05 $00
$00 $00
$A9 $05
$85 $06
$A9 $00
$85 $07
$A8
$11 $06
$00 $00
$A9 $00
$AA
$15 $05
$00 $00
$A9 $00
$A8
$19 $05 $00
$00 $00
$A9 $00
$AA
$1D $05 $00
$00 $00
;
; test program #6
; Test JSR opcode.
; After each break examine memory at $c000 and $c001.
; After 1-st break, $c000 should equal $dd.
; Return address-1 ($0802) should be on stack.
; After 2-nd break, PC counter should be at $0805.
; After 3-rd break, $c000 should equal $ee.
; Return address-1 ($0807) should be on stack.
; After 4-th break, PC counter should be at $080a.
;
; start:
;    jsr sub1
;    brk
;    jsr sub2
;    brk
;    brk
;    brk
; sub1:
;    lda #$dd
;    sta $c000
;    brk
;    rts
; sub2:
;    lda #$ee
;    sta $c000
;    brk
;    rts
;
ORG
$0800
$20 $0B $08
$00 $00
$20 $13 $08
$00
$00
$00
$A9 $DD
$8D $00 $C0
$00 $00
$60
$A9 $EE
$8D $00 $C0
$00 $00
$60
;
; test program #7
; Test ADC opcode.
; Expected results:
; First break: Acc=$01, Carry=1
; 2-nd break: Acc=$02, Carry=1
; 3-rd break: Acc=$22, Carry=0
; 4-th break: Acc=$23, Carry=0
;
; start:
;    clc
;    lda #$ff
;    adc #$02
;    brk
;    sec
;    lda #$ff
;    adc #$02
;    brk
;    clc
;    lda #$20
;    adc #$02
;    brk
;    sec
;    lda #$20
;    adc #$02
;    brk
;
ORG
$0900
$18
$A9 $FF
$69 $02
$00 $00
$38
$A9 $FF
$69 $02
$00 $00
$18
$A9 $20
$69 $02
$00 $00
$38
$A9 $20
$69 $02
$00 $00
;
; test program #8
; Test ROR opcode.
;
; start:
;    sec
;    lda #$00
; loop:
;    ror
;    brk
;    bcc loop ;(-5 -> $FB)
;    brk 
;
ORG
$0920
$38
$A9 $00
$6A
$00 $00
$90 $FB
$00 $00
;

ORG
$0a00
;
; test program #9
; address: $0a00
; load Acc with value 63
; perform four Hadamard operations on Acc
; (should return Acc to 63 by fourth Hadamard,
; or any input to its original value)
; store Acc in $0a10 (to check if in permutation basis state)
;
; lda #$3f
; haa
; haa
; haa
; haa
; sta $0a10
; brk
;
$A9 $3f $02 $02 $02 $02 $8D $10 $0a $00
ORG
$0a10
$00

ORG
$0a20
;
; test program #10
; address: $0a20
; pick an exponentially distributed random integer from 0 to 8
; store result in $0a30
;
; load Acc with value 0
; load IndX with value 0
; perform Hadamard on IndX
; load Acc from page $0e00 
; store Acc in $0a30 (to collapse state)
;
; lda #$00
; ldx #$00
; hax
; lda $0e00,X
; sta $0a30
; brk
;
$A9 $00 $A2 $00 $03 $BD $00 $0e $8D $30 $0A $00
ORG
$0a30
$00
ORG
$0e00
$00 $01 $02 $02 $03 $03 $03 $03 $04 $04 $04 $04 $04 $04 $04 $04
$05 $05 $05 $05 $05 $05 $05 $05 $05 $05 $05 $05 $05 $05 $05 $05
$06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06
$06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06 $06
$07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07
$07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07
$07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07
$07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
$08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08

ORG
$0b00
;
; test program #11
; address: $0b00
; perform Grover's search on "subroutine"
; store result in $0bff
;
; GINIT:	clq
;		ldy #$0c
; 		lda #$00
;		adc #$00 	;clear flags
;		haa
; GITER:	seq
;		sez
;		clc
;		cmp #$64
;		haa
;		clz
;		haa
;               qzz
;		clq
;		dey
;		bne GITER
;		cmp #$64
;		bne GINIT
;		sta $0bff
;		brk
;
$1f $a0 $0c $a9 $00 $69 $00 $02 $3f $2b $18 $c9 $64 $02 $47 $02
$f7 $1f $88 $d0 $f3 $c9 $64 $d0 $e7 $81 $ff $0b $00
ORG
$0c00
;
; test program #12
; address: $0c00
; Search lookup table in $0f00 to $0fff with amplitude amplification
; store result in $0bff
;
; GINIT:	clq
;		ldy #$0c
; 		ldx #$00
;               hax
;               lda $0f00,X
;               cln
;               clv
; GITER:	seq
;		sez
;		clc
;		cmp #$64
;		ehx
;		qzz
;		clz
;		ehx
;		clq
;		dey
;		bne GITER
;		cmp #$64
;		bne GINIT
;		stx $0cff
;		brk
;
$1f $a0 $0c $a2 $00 $03 $bd $00 $0f $2f $b8 $3f $2b $18 $c9 $64
$0b $47 $0b $f7 $1f $88 $d0 $f3 $c9 $64 $d0 $e4 $8e $ff $0c $00 
ORG
$0f00
$ff $fe $fd $fc $fb $fa $f9 $f8 $f7 $f6 $f5 $f4 $f3 $f2 $f1 $f0
$ef $ee $ed $ec $eb $ea $e9 $e8 $e7 $e6 $e5 $e4 $e3 $e2 $e1 $e0
$df $de $dd $dc $db $da $d9 $d8 $d7 $d6 $d5 $d4 $d3 $d2 $d1 $d0
$cf $ce $cd $cc $cb $ca $c9 $c8 $c7 $c6 $c5 $c4 $c3 $c2 $c1 $c0
$bf $be $bd $bc $bb $ba $b9 $b8 $b7 $b6 $b5 $b4 $b3 $b2 $b1 $b0
$af $ae $ad $ac $ab $aa $a9 $a8 $a7 $a6 $a5 $a4 $a3 $a2 $a1 $a0
$9f $9e $9d $9c $9b $9a $99 $98 $97 $96 $95 $94 $93 $92 $91 $90
$8f $8e $8d $8c $8b $8a $89 $88 $87 $86 $85 $84 $83 $82 $81 $80
$7f $7e $7d $7c $7b $7a $79 $78 $77 $76 $75 $74 $73 $72 $71 $70
$6f $6e $6d $6c $6b $6a $69 $68 $67 $66 $65 $64 $63 $62 $61 $60
$5f $5e $5d $5c $5b $5a $59 $58 $57 $56 $55 $54 $53 $52 $51 $50
$4f $4e $4d $4c $4b $4a $49 $48 $47 $46 $45 $44 $43 $42 $41 $40
$3f $3e $3d $3c $3b $3a $39 $38 $37 $36 $35 $34 $33 $32 $31 $30
$2f $2e $2d $2c $2b $2a $29 $28 $27 $26 $25 $24 $23 $22 $21 $20
$1f $1e $1d $1c $1b $1a $19 $18 $17 $16 $15 $14 $13 $12 $11 $10
$0f $0e $0d $0c $0b $0a $09 $08 $07 $06 $05 $04 $03 $02 $01 $00
